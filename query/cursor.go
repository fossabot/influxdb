package query

import (
	"time"

	"github.com/influxdata/influxql"
)

// Series represents the metadata about a series.
type Series struct {
	// Name is the measurement name.
	Name string

	// Tags for the series.
	Tags Tags

	// This is an internal id used to easily compare if a series is the
	// same as another series. Whenever the internal cursor changes
	// to a new series, this id gets incremented. It is not exposed to
	// the user so we can implement this in whatever way we want.
	// If a series is not generated by a cursor, this id is zero and
	// it will instead attempt to compare the name and tags.
	id uint64
}

// SameSeries checks if this is the same series as another one.
// It does not necessarily check for equality so this is different from
// checking to see if the name and tags are the same. It checks whether
// the two are part of the same series in the response.
func (s Series) SameSeries(other Series) bool {
	if s.id != 0 && other.id != 0 {
		return s.id == other.id
	}
	return s.Name == other.Name && s.Tags.ID() == other.Tags.ID()
}

// Equal checks to see if the Series are identical.
func (s Series) Equal(other Series) bool {
	if s.id != 0 && other.id != 0 {
		// If the ids are the same, then we can short-circuit and assume they
		// are the same. If they are not the same, do the long check since
		// they may still be identical, but not necessarily generated from
		// the same cursor.
		if s.id == other.id {
			return true
		}
	}
	return s.Name == other.Name && s.Tags.ID() == other.Tags.ID()
}

// Row represents a single row returned by the query engine.
type Row struct {
	// Time returns the time for this row. If the cursor was created to
	// return time as one of the values, the time will also be included as
	// a time.Time in the appropriate column within Values.
	// This ensures that time is always present in the Row structure
	// even if it hasn't been requested in the output.
	Time int64

	// Series contains the series metadata for this row.
	Series Series

	// Values contains the values within the current row.
	Values []interface{}
}

type Cursor interface {
	// Scan will retrieve the next row and assign the result to
	// the passed in Row. If the Row has not been initialized, the Cursor
	// will initialize the Row.
	// To increase speed and memory usage, the same Row can be used and
	// the previous values will be overwritten while using the same memory.
	Scan(row *Row) bool

	// Stats returns the IteratorStats from the underlying iterators.
	Stats() IteratorStats

	// Err returns any errors that were encountered from scanning the rows.
	Err() error

	// Columns returns the column names and types.
	Columns() []influxql.VarRef

	// Close closes the underlying resources that the cursor is using.
	Close() error
}

// RowCursor returns a Cursor that iterates over Rows.
func RowCursor(rows []Row, columns []influxql.VarRef) Cursor {
	return &rowCursor{
		rows:    rows,
		columns: columns,
	}
}

type rowCursor struct {
	rows    []Row
	columns []influxql.VarRef

	series Series
}

func (cur *rowCursor) Scan(row *Row) bool {
	if len(cur.rows) == 0 {
		return false
	}

	*row = cur.rows[0]
	if row.Series.Name != cur.series.Name || !row.Series.Tags.Equals(&cur.series.Tags) {
		cur.series.Name = row.Series.Name
		cur.series.Tags = row.Series.Tags
		cur.series.id++
	}
	cur.rows = cur.rows[1:]
	return true
}

func (cur *rowCursor) Stats() IteratorStats {
	return IteratorStats{}
}

func (cur *rowCursor) Err() error {
	return nil
}

func (cur *rowCursor) Columns() []influxql.VarRef {
	return cur.columns
}

func (cur *rowCursor) Close() error {
	return nil
}

type timeValuer struct {
	ts  int64
	loc *time.Location
}

func (v timeValuer) Value(key string) (interface{}, bool) {
	if key == "time" {
		t := time.Unix(0, v.ts)
		if v.loc != nil {
			t = t.In(v.loc)
		} else {
			t = t.UTC()
		}
		return t, true
	}
	return nil, false
}

type scannerFunc func(m map[string]interface{}) (int64, string, Tags)

type scannerCursorBase struct {
	fields []influxql.Expr
	m      map[string]interface{}

	series  Series
	columns []influxql.VarRef
	loc     *time.Location

	scan scannerFunc
}

func newScannerCursorBase(scan scannerFunc, fields []*influxql.Field, loc *time.Location) scannerCursorBase {
	typmap := FunctionTypeMapper{}
	exprs := make([]influxql.Expr, len(fields))
	columns := make([]influxql.VarRef, len(fields))
	for i, f := range fields {
		exprs[i] = f.Expr
		columns[i] = influxql.VarRef{
			Val:  f.Name(),
			Type: influxql.EvalType(f.Expr, nil, typmap),
		}
	}

	return scannerCursorBase{
		fields:  exprs,
		m:       make(map[string]interface{}),
		columns: columns,
		loc:     loc,
		scan:    scan,
	}
}

func (cur *scannerCursorBase) Scan(row *Row) bool {
	ts, name, tags := cur.scan(cur.m)
	if ts == ZeroTime {
		return false
	}

	row.Time = ts
	if name != cur.series.Name || tags.ID() != cur.series.Tags.ID() {
		cur.series.Name = name
		cur.series.Tags = tags
		cur.series.id++
	}
	row.Series = cur.series

	if len(cur.columns) > len(row.Values) {
		row.Values = make([]interface{}, len(cur.columns))
	}

	valuer := influxql.ValuerEval{
		Valuer: influxql.MultiValuer(
			&MathValuer{
				Valuer: influxql.MapValuer(cur.m),
			},
			timeValuer{ts: ts, loc: cur.loc},
		),
		IntegerFloatDivision: true,
	}
	for i, expr := range cur.fields {
		row.Values[i] = valuer.Eval(expr)
	}
	return true
}

func (cur *scannerCursorBase) Columns() []influxql.VarRef {
	return cur.columns
}

var _ Cursor = (*scannerCursor)(nil)

type scannerCursor struct {
	scanner IteratorScanner
	scannerCursorBase
}

func newScannerCursor(s IteratorScanner, fields []*influxql.Field, opt IteratorOptions) *scannerCursor {
	cur := &scannerCursor{scanner: s}
	cur.scannerCursorBase = newScannerCursorBase(cur.scan, fields, opt.Location)
	return cur
}

func (s *scannerCursor) scan(m map[string]interface{}) (int64, string, Tags) {
	ts, name, tags := s.scanner.Peek()
	if ts == ZeroTime {
		return ts, name, tags
	}
	s.scanner.ScanAt(ts, name, tags, m)
	return ts, name, tags
}

func (cur *scannerCursor) Stats() IteratorStats {
	return cur.scanner.Stats()
}

func (cur *scannerCursor) Err() error {
	return cur.scanner.Err()
}

func (cur *scannerCursor) Close() error {
	return cur.scanner.Close()
}

var _ Cursor = (*multiScannerCursor)(nil)

type multiScannerCursor struct {
	scanners  []IteratorScanner
	err       error
	ascending bool
	scannerCursorBase
}

func newMultiScannerCursor(scanners []IteratorScanner, fields []*influxql.Field, opt IteratorOptions) *multiScannerCursor {
	cur := &multiScannerCursor{
		scanners:  scanners,
		ascending: opt.Ascending,
	}
	cur.scannerCursorBase = newScannerCursorBase(cur.scan, fields, opt.Location)
	return cur
}

func (cur *multiScannerCursor) scan(m map[string]interface{}) (ts int64, name string, tags Tags) {
	ts = ZeroTime
	for _, s := range cur.scanners {
		curTime, curName, curTags := s.Peek()
		if curTime == ZeroTime {
			if err := s.Err(); err != nil {
				cur.err = err
				return ZeroTime, "", Tags{}
			}
			continue
		}

		if ts == ZeroTime {
			ts, name, tags = curTime, curName, curTags
			continue
		}

		if cur.ascending {
			if (curName < name) || (curName == name && curTags.ID() < tags.ID()) || (curName == name && curTags.ID() == tags.ID() && curTime < ts) {
				ts, name, tags = curTime, curName, curTags
			}
			continue
		}

		if (curName > name) || (curName == name && curTags.ID() > tags.ID()) || (curName == name && curTags.ID() == tags.ID() && curTime > ts) {
			ts, name, tags = curTime, curName, curTags
		}
	}

	if ts == ZeroTime {
		return ts, name, tags
	}

	for _, s := range cur.scanners {
		s.ScanAt(ts, name, tags, m)
	}
	return ts, name, tags
}

func (cur *multiScannerCursor) Stats() IteratorStats {
	var stats IteratorStats
	for _, s := range cur.scanners {
		stats.Add(s.Stats())
	}
	return stats
}

func (cur *multiScannerCursor) Err() error {
	return cur.err
}

func (cur *multiScannerCursor) Close() error {
	var err error
	for _, s := range cur.scanners {
		if e := s.Close(); e != nil && err == nil {
			err = e
		}
	}
	return err
}

// DrainCursor will read and discard all values from a Cursor and return the error
// if one happens.
func DrainCursor(cur Cursor) error {
	var row Row
	for cur.Scan(&row) {
		// Do nothing with the result.
	}
	return cur.Err()
}
